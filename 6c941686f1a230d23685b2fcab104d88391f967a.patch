From 6c941686f1a230d23685b2fcab104d88391f967a Mon Sep 17 00:00:00 2001
From: chrysn <chrysn@fsfe.org>
Date: Wed, 8 Jun 2022 13:18:08 +0200
Subject: [PATCH] c2rust-exporter: Remove Atomics warnings

As atomics are being implemented, these warnings are becoming wrong. Any
operations on atomics that stay unimplmented will be caught more
precisely at later translation stages.
---
 c2rust-ast-exporter/src/AstExporter.cpp | 54 -------------------------
 1 file changed, 54 deletions(-)

diff --git a/c2rust-ast-exporter/src/AstExporter.cpp b/c2rust-ast-exporter/src/AstExporter.cpp
index d5e9e7b68..56cce5c93 100644
--- a/c2rust-ast-exporter/src/AstExporter.cpp
+++ b/c2rust-ast-exporter/src/AstExporter.cpp
@@ -189,24 +189,6 @@ class TypeEncoder final : public TypeVisitor<TypeEncoder> {
           astEncoder(ast) {}
 
     void VisitQualType(const QualType &QT) {
-        if(isa<AtomicType>(QT)) {
-            // No printC11AtomicError available here and no location
-            // information either -- should better have been caught at the
-            // caller, but catching it here is still better than the
-            // nondescript error messages that would come later.
-            std::string msg = "C11 Atomics are not supported. No precise "
-                "location information available. Aborting.";
-
-            auto &DiagEngine = Context->getDiagnostics();
-            // Prefix warnings with `c2rust`, so the user can distinguish
-            // our warning messages from those generated by clang itself.
-            const auto ID = DiagEngine.getCustomDiagID(DiagnosticsEngine::Error,
-                "c2rust: %0");
-            DiagEngine.Report(SourceLocation::getFromRawEncoding(0), ID).AddString(msg);
-
-            abort();
-        }
-
         if (!QT.isNull()) {
             auto s = QT.split();
 
@@ -1919,10 +1901,6 @@ class TranslateASTVisitor final
         // Use the type from the definition in case the extern was an incomplete
         // type
         auto T = def->getType();
-        if(isa<AtomicType>(T)) {
-            printC11AtomicError(def);
-            abort();
-        }
 
         auto loc = is_defn ? def->getLocation() : VD->getLocation();
 
@@ -2006,12 +1984,6 @@ class TranslateASTVisitor final
         auto recordAlignment = 0;
         auto byteSize = 0;
 
-        auto t = D->getTypeForDecl();
-        if(isa<AtomicType>(t)) {
-            printC11AtomicError(D);
-            abort();
-        }
-
         auto loc = D->getLocation();
         std::vector<void *> childIds;
         if (def) {
@@ -2084,12 +2056,6 @@ class TranslateASTVisitor final
         // They are used in actual code and accepted by compilers, so we cannot
         // exit early via code like `if (!D->isCompleteDefinition()) return true;`.
 
-        auto t = D->getTypeForDecl();
-        if(isa<AtomicType>(t)) {
-            printC11AtomicError(D);
-            abort();
-        }
-
         std::vector<void *> childIds;
         for (auto x : D->enumerators()) {
             childIds.push_back(x->getCanonicalDecl());
@@ -2148,10 +2114,6 @@ class TranslateASTVisitor final
 
         std::vector<void *> childIds;
         auto t = D->getType();
-        if(isa<AtomicType>(t)) {
-            printC11AtomicError(D);
-            abort();
-        }
 
         auto record = D->getParent();
         const ASTRecordLayout &layout =
@@ -2206,17 +2168,6 @@ class TranslateASTVisitor final
                          cbor_encode_boolean(array, D->isImplicit());
                      });
 
-        if(isa<AtomicType>(typeForDecl)) {
-            // This case is especially checked as that's what happens when
-            // clang's stdatomic.h is traversed. Other callers of VisitQualType
-            // could get the same check to preserve the location information
-            // available in Decl but not in Type, but those are more likely not
-            // to be hit, and can fall back to the less descriptive error from
-            // inside there.
-            printC11AtomicError(D);
-            abort();
-        }
-
         typeEncoder.VisitQualType(typeForDecl);
 
         return true;
@@ -2373,11 +2324,6 @@ class TranslateASTVisitor final
             CharSourceRange::getCharRange(E->getSourceRange()));
     }
 
-    void printC11AtomicError(Decl *D) {
-        std::string msg = "C11 Atomics are not supported. Aborting.";
-        printError(msg, D);
-    }
-
     void printError(std::string Message, Decl *D) {
         auto DiagBuilder =
                 getDiagBuilder(D->getLocation(), DiagnosticsEngine::Error);
